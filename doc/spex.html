<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Language" content="en" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta name="author" content="FAL Labs" />
<meta name="keywords" content="Kyoto Tycoon, kyototycoon, database, DBM" />
<meta name="description" content="Specifications of Kyoto Tycoon" />
<link rel="contents" href="./" />
<link rel="stylesheet" href="common.css" />
<link rel="icon" href="icon16.png" />
<link rev="made" href="mailto:info@fallabs.com" />
<title>Kyoto Tycoon: a persistent cache server</title>
</head>

<body>

<h1 id="headline">Fundamental Specifications of Kyoto Tycoon Version 1</h1>

<div class="note">Copyright (C) 2009-2010 FAL Labs</div>
<div class="note">Last Update: Wed, 13 Oct 2010 03:23:49 +0900</div>

<hr />

<h2 id="contents">Table of Contents</h2>

<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#tutorial">Tutorial</a></li>
<li><a href="#tips">Tips and Hacks</a></li>
<li><a href="#protocol">Protocol</a></li>
<li><a href="#license">License</a></li>
</ol>

<hr />

<h2 id="introduction">Introduction</h2>

<p>Kyoto Tycoon is a lightweight database server with auto expiration mechanism, which is useful to handle cache data of various applications.  Kyoto Tycoon is also a package of network interface to the DBM called Kyoto Cabinet.  Although the DBM has high performance and high concurrency, you might bother in case that multiple processes share the same database, or remote processes access the database.  Thus, Kyoto Tycoon is provided for concurrent and remote connections to Kyoto Cabinet.  Kyoto Tycoon is composed of the server process managing multiple databases and its access library for client applications.</p>

<p>The server features high concurrency due to thread-pool modeled implementation and the epoll/kqueue mechanism of the modern Linux/*BSD kernel.  It can handle more than 10 thousand connections at the same time.  Because such system-specific features as epoll/kqueue are encapsulated and abstracted as the same interface, Kyoto Tycoon has high portability and works almost all UNIX-like systems and Windows.</p>

<p>The server provides hot backup so that you can make backup data without stopping the server while copying the database files.  Update logging is also supported and it compensates for the difference between the contents of backup files and the current database.  Moreover, the server implements asynchronous replication.  A server sends update logs to other servers, which evaluate the logs immediately and keep their databases catching up to the master database.</p>

<p>The server and its clients communicate with each other by HTTP.  So, you can write client applications and client libraries in almost all popular languages.  Both of RESTful-style interface by the GET, HEAD, PUT, DELETE methods and RPC-style inteface by the POST method are supported.  The RPC-style interface is based on the protocol called TSV-RPC.  The entity bodies of the request and the response are text data formatted as tab-separated-values so that parsing them is very easy.</p>

<p>The server can embed Lua, a lightweight script language.  Even if you cannot find any built-in operation matching your requirement among the client API of Kyoto Tycoon, you can define arbitrary operations by defining functions in Lua.  The API for Lua scripts provides full set of database operations of Kyoto Cabinet including visitor, cursor, and transaction mechanisms.</p>

<p>The server program of Kyoto Tycoon is written in the C++ language.  It is available on platforms which have API conforming to C++03 with the TR1 library extensions.  Kyoto Tycoon is a free software licensed under the GNU General Public License.  You can write client applications which are not under control of our license, by making them just communicate with the server by HTTP without using the core library.</p>

<hr />

<h2 id="installation">Installation</h2>

<p>This section describes how to install Kyoto Tycoon with the source package.  As for a binary package, see its installation manual.</p>

<h3 id="installation_preparation">Preparation</h3>

<p>Kyoto Tycoon is available on UNIX-like systems.  At least, the following environments are supported.  Development for other platworms including Windows is now work-in-progress.</p>

<ul>
<li>Linux 2.6 and later (i386/x86-64/PowerPC/Alpha/SPARC)</li>
<li>Mac OS X 10.5 and later (x86-64)</li>
</ul>

<p><code>gcc</code> (GNU Compiler Collection) 4.2 or later and <code>make</code> (GNU Make) are required to install Kyoto Tycoon with the source package.  They are installed by default on Linux, FreeBSD and so on.</p>

<p>As Kyoto Tycoon depends on the following libraries, install them beforehand.</p>

<ul>
<li><a href="http://www.zlib.net/">ZLIB</a> : for loss-less data compression.  1.2.3 or later is required.</li>
<li><a href="http://fallabs.com/kyotocabinet/">Kyoto Cabinet</a> : lightweight embedded database library.  1.2.15 or later is required.</li>
</ul>

<h3 id="installation_installation">Installation</h3>

<p>When an archive file of Kyoto Tycoon is extracted, change the current working directory to the generated directory and perform installation.</p>

<p>Run the configuration script.</p>

<pre>$ ./configure
</pre>

<p>Build programs.</p>

<pre>$ make
</pre>

<p>Perform self-diagnostic test.  This takes a while.</p>

<pre>$ make check
</pre>

<p>Install programs.  This operation must be carried out by the <code>root</code> user.</p>

<pre># make install
</pre>

<h3 id="installation_result">Result</h3>

<p>When a series of work finishes, the following files will be installed.</p>

<pre>/usr/local/include/ktcommon.h
/usr/local/include/ktutil.h
/usr/local/include/ktsocket.h
/usr/local/include/ktthserv.h
/usr/local/include/kthttp.h
/usr/local/include/ktrpc.h
/usr/local/include/ktulog.h
/usr/local/include/kttimeddb.h
/usr/local/include/ktremotedb.h
/usr/local/lib/libkyototycoon.a
/usr/local/lib/libkyototycoon.so.x.y.z
/usr/local/lib/libkyototycoon.so.x
/usr/local/lib/libkyototycoon.so
/usr/local/lib/pkgconfig/kyototycoon.pc
/usr/local/bin/ktutiltest
/usr/local/bin/ktutilmgr
/usr/local/bin/ktutilserv
/usr/local/bin/kttimedtest
/usr/local/bin/kttimedmgr
/usr/local/bin/ktserver
/usr/local/bin/ktremotetest
/usr/local/bin/ktremotemgr
/usr/local/share/kyototycoon/...
/usr/local/man/man1/...
</pre>

<h3 id="installation_option">Options of Configure</h3>

<p>The following options can be specified with `<code>./configure</code>'.</p>

<ul class="options">
<li><code>--enable-debug</code> : build for debugging.  Enable debugging symbols, do not perform optimization, and perform static linking.</li>
<li><code>--enable-devel</code> : build for development.  Enable debugging symbols, perform optimization, and perform dynamic linking.</li>
<li><code>--enable-profile</code> : build for profiling.  Enable profiling symbols, perform optimization, and perform dynamic linking.</li>
<li><code>--enable-static</code> : build by static linking.</li>
<li><code>--disable-shared</code> : avoid to build shared libraries.</li>
<li><code>--disable-event</code> : avoid to use system-specific event notifiers.</li>
<li><code>--enable-lua</code> : enable the scripting extension by Lua.</li>
</ul>

<p>`<code>--prefix</code>' and other options are also available as with usual UNIX software packages.  If you want to install Kyoto Tycoon under `<code>/usr</code>' not `<code>/usr/local</code>', specify `<code>--prefix=/usr</code>'.  As well, the library search path does not include `<code>/usr/local/lib</code>', it is necessary to set the environment variable `<code>LD_LIBRARY_PATH</code>' to include `<code>/usr/local/lib</code>' before running applications of Kyoto Tycoon.</p>

<h3 id="installation_library">How to Use the Library</h3>

<p>Kyoto Tycoon provides API of the C++ language and it is available by programs conforming to the C++03 standard.  As the header files of Kyoto Tycoon are provided as `<code>ktutil.h</code>', `<code>ktremotedb.h</code>', and so on, applications should include one or more of them accordingly to use the API.  As the library is provided as `<code>libkyototycoon.a</code>' and `<code>libkyototycoon.so</code>' and they depends on underlying system libraries, linker options corresponding to them are required by the build command.  The typical build command is the following.</p>

<pre>$ g++ -I/usr/local/include example.cc -o example \
  -L/usr/local/lib -lkyototycoon -lkyotocabinet -lz -lstdc++ \
  -lresolv -lnsl -ldl -lrt -lpthread -lm -lc
</pre>

<p>If you don't use the core library of C++ but an HTTP library in another language, you don't have to know the above messy rules.</p>

<hr />

<h2 id="tutorial">Tutorial</h2>

<p>This section describes how to use Kyoto Tycoon with the command line utilities and some sample application programs.</p>

<h3 id="tutorial_kickstart">Kick-start</h3>

<p>To begin with, let's run the database server program.  Simply execute the following commnad.  Some log messages are printed on the terminal.</p>

<pre>$ ktserver
2010-10-03T16:24:38.467252+09:00: [SYSTEM]: ================ [START]: pid=19069
2010-10-03T16:24:38.467473+09:00: [SYSTEM]: opening a database: path=*
2010-10-03T16:24:38.467645+09:00: [SYSTEM]: starting the server
2010-10-03T16:24:38.467751+09:00: [SYSTEM]: server socket opened: expr=:1978 timeout=30.0
2010-10-03T16:24:38.467775+09:00: [SYSTEM]: listening server socket started: fd=3
</pre>

<p>The command `<code>ktserver</code>' starts network service accepting commands from clients on local or remote machines.  By default, an unnamed on-memory database is opened and managed by the server through the port 1978.  To finish the server, input `<code>Ctrl-C</code>' on the terminal or send such termination signals as `<code>SIGINT</code>' or `<code>SIGTERM</code>' from another terminal.</p>

<p>Next, insert some records into the database.  Execute the follwoing command on another terminal.  Corresponding access logs will be printed on the server terminal.</p>

<pre>$ ktremotemgr set japan tokyo
$ ktremotemgr set korea seoul
$ ktremotemgr set china beijing
</pre>

<p>The command `<code>ktremotemgr</code>' is a tool kit to manage the database as a client.  The sub command "set" is to set a record.  The first argument next to the sub command name is the key of a record and the second argument is the value of the record.</p>

<p>Retrieve the records by the key of each record using the sub command "get".</p>

<pre>$ ktremotemgr get japan
tokyo
$ ktremotemgr get korea
seoul
$ ktremotemgr get china
beijing
</pre>

<p>Remove a record by the key using the sub command "remove".</p>

<pre>$ ktremotemgr remove japan
</pre>

<p>Print the keys of all records using the sub command "list".</p>

<pre>$ ktremotemgr list
korea
china
</pre>

<p>That's all for the fundamental operations.  The KVS family have been improving performance thanks to discarding the functionality.  See the specification of `<a href="command.html#ktserver">ktserver</a>' and `<a href="command.html#ktremotemgr">ktremotemgr</a>' for more detail.</p>

<h3 id="tutorial_httpcmd">Using HTTP Clients</h3>

<p>Because every operation of the database is called via HTTP, you can use any HTTP client utility such as `<code>curl</code>' to operate the database.</p>

<pre># setting records
$ curl "http://localhost:1978/rpc/set?key=japan&amp;value=tokyo"

# retrieving records
$ curl "http://localhost:1978/rpc/get?key=japan"
value   tokyo

# removing records
$ curl "http://localhost:1978/rpc/remove?key=japan"
</pre>

<p>RESTful-style interface is also supported in addition to the above RPC-style interface.</p>

<pre># setting records
$ echo -n tokyo | curl -X PUT -T - "http://localhost:1978/japan"

# retrieving records
$ curl "http://localhost:1978/japan"
tokyo

# removing records
$ curl -X DELETE "http://localhost:1978/japan"
</pre>

<p>Of cource, you can use your favorite scripting languages and libraries for more complex use cases.  Because Kyoto Tycoon supports keep-alive connection mechanism, using libraries which support keep-alive is strongly suggested for performance reason.</p>

<h3 id="tutorial_expiration">Expiration of Records</h3>

<p>One of the most important features of Kyoto Tycoon is expiration mechanism of records.  That is, you can specify the expiration time when inserting a record.  The record is automatically deleted after the current time exceeds the expiration time.</p>

<p>To insert a record which will be expired one minute after, execute the following command.</p>

<pre>$ ktremotemgr set -xt 60 japan tokyo
</pre>

<p>Check the record immediately before the expiration.  The "-pt" option shows the expiration time in seconds from the epoch.</p>

<pre>$ ktremotemgr get -pt japan
tokyo   1286108387
</pre>

<p>Wait for more than one minute, and then retrieve the record again.  It will be missing.</p>

<pre>$ ktremotemgr get -pt japan
ktremotemgr: DB::get failed: :1978: 2: logical inconsistency: DB: 7: no record: no record
</pre>

<p>You can do the same things with an arbitrary HTTP client by specifiying the "xt" parameter.</p>

<pre>$ curl "http://localhost:1978/rpc/set?key=japan&amp;value=tokyo&amp;xt=60"
$ curl "http://localhost:1978/rpc/get?key=japan"
value   tokyo
xt      1286109204
$ sleep 60
$ curl "http://localhost:1978/rpc/get?key=japan"
ERROR   DB: 7: no record: no record
</pre>

<h3 id="tutorial_kctremoteex">Sample Application of the Remote Database</h3>

<p>Leaving command line interface, let's write a sample application program handling a remote database.  See the following source code.</p>

<pre>#include &lt;ktremotedb.h&gt;

using namespace std;
using namespace kyototycoon;

// main routine
int main(int argc, char** argv) {

  // create the database object
  RemoteDB db;

  // open the database
  if (!db.open()) {
    cerr &lt;&lt; "open error: " &lt;&lt; db.error().name() &lt;&lt; endl;
  }

  // store records
  if (!db.set("foo", "hop") ||
      !db.set("bar", "step") ||
      !db.set("baz", "jump")) {
    cerr &lt;&lt; "set error: " &lt;&lt; db.error().name() &lt;&lt; endl;
  }

  // retrieve a record
  string* value = db.get("foo");
  if (value) {
    cout &lt;&lt; *value &lt;&lt; endl;
    delete value;
  } else {
    cerr &lt;&lt; "get error: " &lt;&lt; db.error().name() &lt;&lt; endl;
  }

  // traverse records
  RemoteDB::Cursor* cur = db.cursor();
  cur-&gt;jump();
  pair&lt;string, string&gt;* rec;
  while ((rec = cur-&gt;get_pair(NULL, true)) != NULL) {
    cout &lt;&lt; rec-&gt;first &lt;&lt; ":" &lt;&lt; rec-&gt;second &lt;&lt; endl;
    delete rec;
  }
  delete cur;

  // close the database
  if (!db.close()) {
    cerr &lt;&lt; "close error: " &lt;&lt; db.error().name() &lt;&lt; endl;
  }

  return 0;
}
</pre>

<p>Save the above code as a file "example.cc".  Then, perform the following command line.  The command `<code>kcutilmgr conf</code>' prints the building configuration.</p>

<pre>$ g++ `ktutilmgr conf -i` -o example example.cc `ktutilmgr conf -l`
</pre>

<p>Execute the application program built by the above.  Of course, run the database server on another terminal beforehand.</p>

<pre>$ ./example
hop
foo:hop
bar:step
baz:jump
</pre>

<p>The API of the remote database is defined in the header `<code>ktremote.h</code>'.  So, include the header near the front of a source file.  All symbols of Kyoto Tycoon are packaged in the name space `<code>kyototycoon</code>'.  You can use them without any prefix by importing the name space.</p>

<pre>#include &lt;ktremotedb.h&gt;
using namespace kyototycoon;
</pre>

<p>The class `<code>RemoteDB</code>' contains all functionality of the remote database and each instance expresses a remote database file.</p>

<pre>RemoteDB db;
</pre>

<p>Each connection must be opened by the `<code>open</code>' method before any database operation.  Although it takes three parameters, all of them can be omitted.  The first parameter specifies the host name of the server and the default value is the name of the local host.  The second parameter specifies the port number and the default value is 1978 which is the same as the default port of the database server.  The third parameter specifies the timeout of network operation in seconds and the default value is no timeout.</p>

<pre>db.open();
</pre>

<p>Every opened connection should be closed by the `<code>close</code>' method when it is no longer in use.</p>

<pre>db.close();
</pre>

<p>To store a record, use the `<code>set</code>' method with the key and the value.</p>

<pre>db.put("foo", "hop");
</pre>

<p>To retrieve the value of a record, use the `<code>get</code>' method with the key.  The return value is NULL if no record corresponds to the key.  On success, the return value is the pointer to a dynamic object and it should be deleted explicitly after the use.</p>

<pre>string* value = db.get("foo", "hop");
if (value) {
  cout &lt;&lt; *value &lt;&lt; endl;
  delete value;
}
</pre>

<p>Except for `<code>set</code>' and `<code>get</code>', there are other methods; `<code>add</code>', `<code>replace</code>', `<code>append</code>', `<code>remove</code>', `<code>increment</code>', and `<code>cas</code>'.  Each method has two versions; for `<code>std::string</code>' parameters and for `<code>char*</code>' and `<code>size_t</code>' parameters.</p>

<p>Traversing records is a bit complicated task.  It needs a cursor object, which expresses the current position in the sequence of all records in the database.  Each cursor is created by the `<code>cursor</code>' method of the database object.  Each cursor should be initialized by `<code>jump</code>' method before actual record operations.</p>

<pre>RemoteDB::Cursor* cur = db.cursor();
cur-&gt;jump();
</pre>

<p>The cursor class has such methods against the record at the current position as `<code>set_value</code>', `<code>remove</code>', `<code>get_key</code>', `<code>get_value</code>', and `<code>get_pair</code>'.  Most methods have an optional stepping parameter to shift the current position to the next record atomically.  Therefore, iterating such methods with the stepping parameter results in that all records are visited.</p>

<pre>pair&lt;string, string&gt;* rec;
while ((rec = cur.get_pair(true)) != NULL) {
  cout &lt;&lt; rec-&gt;first &lt;&lt; ":" &lt;&lt; rec-&gt;second &lt;&lt; endl;
  delete rec;
}
</pre>

<p>Please see the <a href="api/">the API documents</a> for detail.  Writing your own sample application is the best way to learn this library.</p>

<h3 id="tutorial_script">Scripting Extension</h3>

<p>If you configured Kyoto Tycoon with the "--enable-lua" option, the scripting extension by Lua is available.  The following is an example code to define a simple operation to store a record.</p>

<pre>kt = __kyototycoon__
db = kt.db

function set(inmap, outmap)
   local key = inmap.key
   local value = inmap.value
   if not key or not value then
      return kt.RVEINVALID
   end
   local xt = inmap.xt
   if not db:set(key, value, xt) then
      return kt.RVEINTERNAL
   end
   return kt.RVSUCCESS
end
</pre>

<p>If you save the above code as "test.lua", you can embed the operation by stating the server as the following.</p>

<pre>$ ktserver -scr test.lua
</pre>

<p>To call the operation, execute the following command.</p>

<pre>$ ktremotemgr script -arg key japan -arg value japan -arg xt 60 set
</pre>

<p>See the specification of <a href="luadoc/">the scripting extension</a> for more detail.</p>

<hr />

<h2 id="tips">Tips and Hacks</h2>

<p>This section describes tips and hacks to use Kyoto Tycoon.</p>

<h3 id="tips_typicalserver">Typical Server Setting</h3>

<p>On the assumption that you runs the server of Kyoto Tycoon on an machine with 16GB main memory and stores 10 million records into a file hash database, the following setting is suggested.</p>

<pre>$ ktserver -port 1978 -tout 10 \
  -log /var/data/ktserver.log -ls \
  -dmn -pid /var/data/ktserver.pid \
  '/var/data/casket.kch#opts=l#bnum=20000000#msiz=12g#dfunit=8'
</pre>

<p>To improve performance, the bucket number of the hash table by the "bnum" parameter should be two times or more of the number of records.  The size of mapped memory by the "msiz" parameter should be largest as far as the main memory is available.  The unit number of auto defragmentation by the "dfunit" parameter should be about 8 which means every eight detected fragmentations causes a series of auto defragmentation steps.  If you want more high availability at the cost of performance, using auto transaction by the "-oat" option is a good idea.  For detail about database tuning, see <a href="http://fallabs.com/kyotocabinet/spex.html#tips">the tips of Kyoto Cabinet</a>.</p>

<p>The option "-dmn" switches the process into the background, which is called daemon.  To stop or restart a daemon process, the PID files should be specified by the "-pid" option.  The PID file contains the process ID by which you can send signals.</p>

<p>By default, verbose log messages are output and printed into the standard output.  For usual use case, the "-ls" option which filters them is suggested.  The "-log" option specifies the file to store log messages.</p>

<p>To stop the above daemon process, execute the following command.</p>

<pre>$ kill -TERM `cat /var/data/ktserver.pid`
</pre>

<p>To rotate the log file of the above daemon process, execute the following command.</p>

<pre>$ mv -f /var/data/ktserver.log /var/data/ktserver.log.`date '+%Y%M%d%H%M%S'`
$ kill -HUP `cat /var/data/ktserver.pid`
</pre>

<h3 id="tips_onmemoryserver">On-memory Server Setting</h3>

<p>You can use Kyoto Tycoon as a volatile (not persistent) cache server with an on-memory database.  In most cases, space efficiency of Kyoto Tycoon is better than that of memcached.  If it is expected that 10 million records are cached in the database using 10GB memory, the following setting is suggested.</p>

<pre>$ ktserver ':#bnum=20000000#ktcapsiz=10g'
</pre>

<p>Note that the capacity tuning parameter limits the total size of memory allocation in the "user land" layer.  So, actual memory usage will be probably higher than the limit size.  For peaceful operation, the limit should be up to 65% of the total memory size of the machine.</p>

<p>In addition, auto deletion by the capacity limit is performed at random.  In that case, fresh records may also be deleted soon.  So, setting effectual expiration time not to reach the limit is very important.  If you cannot calculate effectual expiration time beforehand, use the cache hash database instead of the default stash database.  The following setting is suggested.</p>

<pre>$ ktserver '*#bnum=20000000#capsiz=8g'
</pre>

<p>Note that the space effiency of the cache hash database is worse than that of the stash database.  The limit should be up to 50% of the total memory size of the machine.  However, auto deletion by the "capsiz" parameter (not "ktcapsiz") of the cache hash database is based on LRU algorithm, which prevents fresh records from sudden deletion.</p>

<h3 id="tips_expiration">Inside Expiration</h3>

<p>The timed database is a database type of wrapper of the polymorphic database of Kyoto Cabinet.  The value of each record in the timed database has the 5 bytes prefix to contain the expiration time in seconds from the epoch.  When a database operation accesses a record, the current time and the expiration time of the record is compared.  If the former is larger, the record is regarded as expired.</p>

<p>In order to eliminate or reuse regions of expired records, the timed database has an implicit cursor called "GC cursor".  Every several updating operations have the GC cursor scan the database gradually.  If a scanned record has been expired, the record is removed and its region is registered to the reusable list.  When the GC cursor reaches the end of the database, the tail end unused regions are discarded and the size of the database file is reduced.  Thus, meta data such as "count" and "size" have latency from the current status.</p>

<p>The above algorithm means that the GC cursor does not work while the database is not being updated.  However, while the server is idle, the GC cursor works implicitly so that the database keeps compact.  Moreover, If you want to cause the full GC operation explicitly, you can call the "vacuum" procedure.</p>

<pre>$ ktremotemgr vacuum
</pre>

<p>If you use Kyoto Tycoon for data storage not for cache, create the database with the persistent option by "#ktopts=p" parameter to disable the GC cursor and omit the time stamp region of each record, for the sake of time and space efficiency.  Note that the persistent option works when creating a database and it does not work for existing databases.</p>

<h3 id="tips_hotbackup">Hot Backup</h3>

<p>You can make backup files while the server is running, which is called "hot backup".  To do it, prepare the following shell script beforehand and save it as "/ktbin/dbbackup".  It must have executable permissions.</p>

<pre>#! /bin/sh
srcfile="$1"
destfile="$1.$2"
cp -f "$srcfile" "$destfile"
</pre>

<p>Run the server specifying the command search path "/ktbin".</p>

<pre>$ ktserver -cmd /ktbin casket.kch
</pre>

<p>When you want to make a backup file, execute the following command to call the backup script.</p>

<pre>$ ktremotemgr sync -cmd dbbackup
</pre>

<p>The "sync" sub command of the client utility makes the database synchronize, which means dirty buffers on memory are written into the database file.  If the "-cmd" option is specified, an outer command is executed with two arguments.  The first argument is the path of the database file.  The second argument is the current time stamp.  You can call arbitrary scripts other than the above sample.  Using "snapshot" mechanism of the underlying operating system is a good idea to shorten the time to make a backup file.</p>

<h3 id="tips_updatelog">Update Logging</h3>

<p>Even if you take hot backup a day, update operations in 24 hours at most might be lost when an accident occurred.  "update log" is provided to compensate for such data loss.  It keeps track of every update operation in "record-base" model, which is called "row-base" in the context of RDBMS.  You can recover the database entirely by applying update logs to the latest backup database file.</p>

<p>Run the server with update logging enabled.  The "-ulog" option specifies the directory to contain the update log files.  The "-sid" option specifies the server ID between 0 to 65535.  The "-cmd" option enables hot backup by the above instruction.</p>

<pre>$ ktserver -ulog 0001-ulog -sid 1 casket.kch -cmd /ktbin casket.kch
</pre>

<p>Insert some records.</p>

<pre>$ ktremotemgr set one first
$ ktremotemgr set two second
</pre>

<p>Take a backup file.</p>

<pre>$ ktremotemgr sync -cmd dbbackup
</pre>

<p>Insert more records.</p>

<pre>$ ktremotemgr set three third
$ ktremotemgr set four fourth
</pre>

<p>Terminate the server by Ctrl-C and remove the database to simulate database crash.</p>

<pre>$ rm casket.kch
</pre>

<p>Recover the database by applying update logs.  "xxx..." means the time stamp of the backup database file.  The "-ts" option specifies the time stamp until which old update logs are skipped.</p>

<pre>$ cp casket.kch.xxxxxxxxxxxxxxxxxxxx casket.kch
$ kttimedmgr recover -ts xxxxxxxxxxxxxxxxxxxx casket.kch 0001-ulog
.. (2)
</pre>

<p>Confirm the records in the recovered database.</p>

<pre>$ kttimedmgr list -pv casket.kch
one     first
two     second
three   third
four    fourth
</pre>

<p>Update logs are saved in respective files by constant size, which is 256MB by default.  After you take a backup database file, you can remove older update logs than the time stamp of the backup database file.  The command "ktutilmgr ulog -uf" prints the maximum time stamp in each update log file.</p>

<pre>$ ktutilmgr ulog -uf 0001-ulog
0001-ulog/0000000001.ulog       268458906       1290785652985000714
0001-ulog/0000000002.ulog       268454950       1290785658832000566
0001-ulog/0000000003.ulog       268437175       1290785665973002820
0001-ulog/0000000004.ulog       268467425       1290785674515001949
0001-ulog/0000000005.ulog       268482363       1290785680925001536
0001-ulog/0000000006.ulog       268497323       1290785689024002042
0001-ulog/0000000007.ulog       268443005       1290785695789001021
0001-ulog/0000000008.ulog       268489073       1290785707323002488
0001-ulog/0000000009.ulog       250047728       1290785715612001421
</pre>

<h3 id="tips_replication">Asynchronous Replication</h3>

<p>Even if you take hot backup and update logs, all data might be lost when the storage device or the computer itself broke down.  Keep in mind that everything is vanity.  To overcome such critical situation, data replication is supported.  It is a mechanism to synchronize two or more database servers for high availability and high integrity.  The replication source server is called "master" and each destination server is called "slave".  Replication requires the following preconditions.</p>

<ul>
<li>The master must record the update log.</li>
<li>The master must specify the unique server ID.</li>
<li>Each slave must record the update log because it may become the master when fail over.</li>
<li>Each slave must specify the unique server ID because of the same reason.</li>
<li>Each slave must specify the address and the port number of the master server.</li>
<li>Each slave must specify the replication time stamp file.</li>
</ul>

<p>This section describes how to set up one master (at port 1978) and one slave (at port 1979) replication.  First, run the master server.</p>

<pre>$ ktserver -port 1978 -ulog 0001-ulog -sid 1 casket-0001.kch
</pre>

<p>Next, run the slave server.</p>

<pre>$ ktserver -port 1979 -ulog 0002-ulog -sid 2 \
  -mhost localhost -mport 1978 -rts 0002.rts casket-0002.kch
</pre>

<p>Insert some records into the master.</p>

<pre>$ ktremotemgr set -port 1978 one first
$ ktremotemgr set -port 1978 two second
</pre>

<p>Check consistency of stored records in the master and the slave.</p>

<pre>$ ktremotemgr list -port 1978 -pv
one     first
two     second
$ ktremotemgr list -port 1979 -pv
one     first
two     second
</pre>

<p>Simulate the case that the master is crashed.  Terminate the master by Ctrl-C and remove the database file.</p>

<pre>$ rm casket-0001.kch
</pre>

<p>Terminate the slave by Ctrl-C and restart it as the new master.</p>

<pre>$ ktserver -port 1979 -ulog 0002-ulog -sid 2 casket-0002.kch
</pre>

<p>Add a new slave at port 1980.</p>

<pre>$ ktserver -port 1980 -ulog 0003-ulog -sid 3 \
  -mhost localhost -mport 1979 -rts 0003.rts casket-0003.kch
</pre>

<p>Check consistency of stored records in the new master and the new slave.</p>

<pre>$ ktremotemgr list -port 1979 -pv
one     first
two     second
$ ktremotemgr list -port 1980 -pv
one     first
two     second
</pre>

<p>Kyoto Tycoon supports "dual master" replication which realizes higher availability.  To do it, run two servers which replicate each other.  Note that updating both of the masters at the same time might cause inconsistency of their databases.</p>

<hr />

<h2 id="protocol">Protocol</h2>

<p>This section describes detail specifications of the protocol of Kyoto Tycoon.</p>

<h3 id="protocol_overview">Overview</h3>

<p>The server program of Kyoto Cabinet communicates with clients by HTTP.  Although the default service port number is 1978, it can be changed by setting.  The server understands requests of HTTP/1.0 and HTTP/1.1 and sends responses corresponding to each request.</p>

<p>If the request is HTTP/1.1 and the value of the "Content-Type" header is not "close", the server try to perform keep-alive connection.  Keep-alive connection is strongly suggested to access the server for performance reason.  However, usual intermissive connection is also allowed for legacy clients.</p>

<p>Kyoto Cabinet uses an RPC model called TSV-RPC, which is similar to XML-RPC but uses TSV (tab separated values) rather than XML.  Although TSV is inferior to XML in terms of expressive ability, TSV is superior to XML in terms of simplicity, space efficiency, and processing effectiveness.</p>

<h3 id="protocol_tsvrpc">TSV-RPC</h3>

<p>TSV-RPC is a client-server modeled synchronous RPC protocol over HTTP.  The following pseudo code is the common interface of each procedure.  TSV is used to serialize the input data and the output data.</p>

<pre>int call(String name, StringMap inmap, StringMap outmap);
</pre>

<p>Each procedure has its entry point under the path "/rpc/" of URL.  For example the entry point of the command "set" is "/rpc/set".  Clients call each command by the POST method specifying the entry point.  Each procedure receives the input data of an associative array composed of key/value string records.  The associative array is expressed by the entity body formatted in TSV text.  Each line expresses a record.  The first column is the key and the second column is the value.  The value of the "Content-Type" header must be "text/tab-separated-values".  The following is a typical request message.</p>

<pre>POST /rpc/set HTTP/1.1
Host: localhost:1978
Content-Type: text/tab-separated-values
Content-Length: 22

key     japan
value   tokyo
</pre>

<p>If a column includes one or more special characters such as tab, line-feed, and control characters, every column must be encoded by one of the following algorithms.</p>

<ul>
<li>Base64 encoding: colenc=B</li>
<li>Quoted-printable: colenc=Q</li>
<li>URL encoding: colenc=U</li>
</ul>

<p>The encoding name must be described as an attribute of the value of the Content-Type header.  The following is a typical request message with encoded TSV data.</p>

<pre>POST /rpc/hello HTTP/1.1
Host: localhost:1978
Content-Type: text/tab-separated-values; colenc=B
Content-Length: 24

aWQ=    MTIzNDU=
YWdl    MzE=
</pre>

<p>As a facile method, clients can send the input data by the entity body in HTML-form format.  That is, the key and the value of a record are encoded respectively in URL encoding and they are concatenated with the "=" character.  All serialized record expressions are concatenated with the "&amp;" character.  The value of the Content-Type header is "application/x-www-form-urlencoded".  The following is a typical request with HTML-form data.</p>

<pre>POST /rpc/goodbye HTTP/1.1
Host: localhost:1978
Content-Type: application/x-www-form-urlencoded
Content-Length: 31

id=1234&amp;name=%e5%b9%b9%e9%9b%84
</pre>

<p>As a more facile method, clients can use the GET method and specify the input data as the query string with the target path.  The following is an example.</p>

<pre>GET /rpc/paint?color=red&amp;x=30&amp;y=20 HTTP/1.1
Host: localhost:1978
</pre>

<p>Clients can select one of TSV, HTML-form, and query string arbitrarily.  However, not that the query string has limit of length, which is 8192 bytes as for Kyoto Tycoon.  TSV with Base64 encoding is recommended for arbitrary string and binary data because its space efficiency is the best of the three formats.</p>

<p>After receiving a request, the server send the result of computation in the response.  The status code of HTTP is one of the follwoing.</p>

<ul>
<li>200: the processing is done successfully.</li>
<li>400: the format of the request is invalid or the arguments are short for the called procedure.</li>
<li>450: the processing is done but the result is not fulfill the application logic.</li>
<li>500: the processing is aborted by fatal error of the server program or the environment.</li>
<li>501: the specified procedure is not implemented.</li>
</ul>

<p>200 and 450 is in normality.  400 indicates bugs in the client side.  500 indicates bugs in the server side.  501 is in the literature.</p>

<p>If the status code is 200, the output data of the procedure is sent as the entity body of the response message.  The output data is also an associative array composed of key/value string records.  The format rules are the same as the ones of the input data.  The following is a typical response message.</p>

<pre>HTTP/1.1 200 OK
Content-Type: text/tab-separated-values; colenc=U
Content-Length: 25

value   %e5%b9%b3%e6%9e%97
</pre>

<p>If the status code is other than 200, error information is sent as the entity body of the response message.  It is an assiciative array including one record whose key is "ERROR" and value is the error message.  The following is an example.</p>

<pre>HTTP/1.1 501 Not Implemented
Content-Type: text/tab-separated-values
Content-Length: 24

ERROR   no such procedure
</pre>

<p>The server select the best encoding by scanning the output data.  That is, raw data is selected if encoding is not needed.  URL encoding is selected if ASCII characters are relatively many.  Base64 is selected in the other cases.  Because Quoted-printable is never selected by the server, clients don't have to implement it.</p>

<h3 id="protocol_commonargs">Common Arguments</h3>

<p>The input data of each procedure can be regarded as named paramters.  Although each procedure needs various parameters different with each other, there are common arguments used by several procedures.</p>

<p>Remember that the server can handle multiple databases at the same time.  Opened databases are distinguished by their ID numbers from 0 to N-1 in the order of the command line arguments.  By default, the first database whose ID number is 0 is selected.  The "DB" parameter specifies the identifier of the target database of each operation.  If the identifier starts with a number, it is treated as the ID number.  Otherwise, it is treated as a database name.  The name of each database is made of the file name after the last "/" character of the path.  The following example stores a record into the database named "phone_db.kch".</p>

<pre>POST /rpc/set HTTP/1.1
Host: localhost:1978
Content-Type: text/tab-separated-values
Content-Length: 47

DB      phone_db.kch
key     09012345678
value   John Doe
</pre>

<p>While keep-alive connection, clients can use cursor objects.  Each cursor has the ID number from 0 to 2^63.  Because each connection has a separate name space with each other, the same ID number can be used among different connections.  The cursor ID is specified by the "CUR" parameter.  If an unknown ID is specified, a new cursor with the ID numger is created.  The following example creates a cursor whose ID is 8 and sets its position to the record whose key is "mikio".</p>

<pre>POST /rpc/cur_jump HTTP/1.1
Host: localhost:1978
Content-Type: text/tab-separated-values
Content-Length: 32

DB      staff_db.kch
CUR     8
key     mikio
</pre>

<p>Cursur objects can be reused in the same connection by specifyin the ID number.  When each connection is closed, cursor objects created while the connection are destroyed automatically and related resources are cleaned-up.</p>

<h3 id="protocol_procedures">Procedures</h3>

<p>The server provides the following procedures.</p>

<dl>
<dt><code>/rpc/echo</code></dt>
<dd>Echo back the input data as the output data, just for testing.</dd>
<dd>input: (optional): arbitrary records.</dd>
<dd>output: (optional): corresponding records to the input data.</dd>
<dd>status code: 200.</dd>
</dl>

<dl>
<dt><code>/rpc/report</code></dt>
<dd>Get the report of the server information.</dd>
<dd>output: (optional): arbitrary records.</dd>
<dd>status code: 200.</dd>
</dl>

<dl>
<dt><code>/rpc/play_script</code></dt>
<dd>Call a procedure of the script language extension.</dd>
<dd>input: <code>name</code>: the name of the procedure to call.</dd>
<dd>input: (optional): arbitrary records whose keys trail the character "_".</dd>
<dd>output: (optional): arbitrary keys which trail the character "_".</dd>
<dd>status code: 200, 450 (arbitrary logical error).</dd>
</dl>

<dl>
<dt><code>/rpc/status</code></dt>
<dd>Get the miscellaneous status information of a database.</dd>
<dd>input: <code>DB</code>: (optional): the database identifier.</dd>
<dd>output: <code>count</code>: the number of records.</dd>
<dd>output: <code>size</code>: the size of the database file.</dd>
<dd>output: (optional): arbitrary records for other information.</dd>
<dd>status code: 200.</dd>
</dl>

<dl>
<dt><code>/rpc/clear</code></dt>
<dd>Remove all records in a database.</dd>
<dd>input: <code>DB</code>: (optional): the database identifier.</dd>
<dd>status code: 200.</dd>
</dl>

<dl>
<dt><code>/rpc/synchronize</code></dt>
<dd>Synchronize updated contents with the file and the device.</dd>
<dd>input: <code>DB</code>: (optional): the database identifier.</dd>
<dd>input: <code>hard</code>: (optional): for physical synchronization with the device.</dd>
<dd>input: <code>command</code>: (optional): the command name to process the database file.</dd>
<dd>status code: 200, 450 (the postprocessing command failed).</dd>
</dl>

<dl>
<dt><code>/rpc/set</code></dt>
<dd>Set the value of a record.</dd>
<dd>input: <code>DB</code>: (optional): the database identifier.</dd>
<dd>input: <code>key</code>: the key of the record.</dd>
<dd>input: <code>value</code>: the value of the record.</dd>
<dd>input: <code>xt</code>: (optional): the expiration time from now in seconds.  If it is negative, the absolute value is treated as the epoch time.  If it is omitted, no expiration time is specified.</dd>
<dd>status code: 200.</dd>
</dl>

<dl>
<dt><code>/rpc/add</code></dt>
<dd>Add a record.</dd>
<dd>input: <code>DB</code>: (optional): the database identifier.</dd>
<dd>input: <code>key</code>: the key of the record.</dd>
<dd>input: <code>value</code>: the value of the record.</dd>
<dd>input: <code>xt</code>: (optional): the expiration time from now in seconds.  If it is negative, the absolute value is treated as the epoch time.  If it is omitted, no expiration time is specified.</dd>
<dd>status code: 200, 450 (existing record was detected).</dd>
</dl>

<dl>
<dt><code>/rpc/replace</code></dt>
<dd>Replace the value of a record.</dd>
<dd>input: <code>DB</code>: (optional): the database identifier.</dd>
<dd>input: <code>key</code>: the key of the record.</dd>
<dd>input: <code>value</code>: the value of the record.</dd>
<dd>input: <code>xt</code>: (optional): the expiration time from now in seconds.  If it is negative, the absolute value is treated as the epoch time.  If it is omitted, no expiration time is specified.</dd>
<dd>status code: 200, 450 (no record was corresponding).</dd>
</dl>

<dl>
<dt><code>/rpc/append</code></dt>
<dd>Append the value of a record.</dd>
<dd>input: <code>DB</code>: (optional): the database identifier.</dd>
<dd>input: <code>key</code>: the key of the record.</dd>
<dd>input: <code>value</code>: the value of the record.</dd>
<dd>input: <code>xt</code>: (optional): the expiration time from now in seconds.  If it is negative, the absolute value is treated as the epoch time.  If it is omitted, no expiration time is specified.</dd>
<dd>status code: 200.</dd>
</dl>

<dl>
<dt><code>/rpc/increment</code></dt>
<dd>Add a number to the numeric integer value of a record.</dd>
<dd>input: <code>DB</code>: (optional): the database identifier.</dd>
<dd>input: <code>key</code>: the key of the record.</dd>
<dd>input: <code>num</code>: the additional number.</dd>
<dd>input: <code>xt</code>: (optional): the expiration time from now in seconds.  If it is negative, the absolute value is treated as the epoch time.  If it is omitted, no expiration time is specified.</dd>
<dd>output: <code>num</code>: the result value.</dd>
<dd>status code: 200, 450 (the existing record was not compatible).</dd>
</dl>

<dl>
<dt><code>/rpc/increment_double</code></dt>
<dd>Add a number to the numeric double value of a record.</dd>
<dd>input: <code>DB</code>: (optional): the database identifier.</dd>
<dd>input: <code>key</code>: the key of the record.</dd>
<dd>input: <code>num</code>: the additional number.</dd>
<dd>input: <code>xt</code>: (optional): the expiration time from now in seconds.  If it is negative, the absolute value is treated as the epoch time.  If it is omitted, no expiration time is specified.</dd>
<dd>output: <code>num</code>: the result value.</dd>
<dd>status code: 200, 450 (the existing record was not compatible).</dd>
</dl>

<dl>
<dt><code>/rpc/cas</code></dt>
<dd>Perform compare-and-swap.</dd>
<dd>input: <code>DB</code>: (optional): the database identifier.</dd>
<dd>input: <code>key</code>: the key of the record.</dd>
<dd>input: <code>oval</code>: (optional): the old value.  If it is omittted, no record is meant.</dd>
<dd>input: <code>nval</code>: (optional): the new value.  If it is omittted, the record is removed.</dd>
<dd>input: <code>xt</code>: (optional): the expiration time from now in seconds.  If it is negative, the absolute value is treated as the epoch time.  If it is omitted, no expiration time is specified.</dd>
<dd>status code: 200, 450 (the old value assumption was failed).</dd>
</dl>

<dl>
<dt><code>/rpc/remove</code></dt>
<dd>Remove a record.</dd>
<dd>input: <code>DB</code>: (optional): the database identifier.</dd>
<dd>input: <code>key</code>: the key of the record.</dd>
<dd>status code: 200, 450 (no record was found).</dd>
</dl>

<dl>
<dt><code>/rpc/get</code></dt>
<dd>Retrieve the value of a record.</dd>
<dd>input: <code>DB</code>: (optional): the database identifier.</dd>
<dd>input: <code>key</code>: the key of the record.</dd>
<dd>output: <code>value</code>: (optional): the value of the record.</dd>
<dd>output: <code>xt</code>: (optional): the absolute expiration time.  If it is omitted, there is no expiration time.</dd>
<dd>status code: 200, 450 (no record was found).</dd>
</dl>

<dl>
<dt><code>/rpc/set_bulk</code></dt>
<dd>Store records at once.</dd>
<dd>input: <code>DB</code>: (optional): the database identifier.</dd>
<dd>input: <code>xt</code>: (optional): the expiration time from now in seconds.  If it is negative, the absolute value is treated as the epoch time.  If it is omitted, no expiration time is specified.</dd>
<dd>input: (optional): arbitrary records whose keys trail the character "_".</dd>
<dd>output: <code>num</code>: the number of stored reocrds.</dd>
<dd>status code: 200.</dd>
</dl>

<dl>
<dt><code>/rpc/remove_bulk</code></dt>
<dd>Store records at once.</dd>
<dd>input: <code>DB</code>: (optional): the database identifier.</dd>
<dd>input: (optional): arbitrary keys which trail the character "_".</dd>
<dd>output: <code>num</code>: the number of removed reocrds.</dd>
<dd>status code: 200.</dd>
</dl>

<dl>
<dt><code>/rpc/get_bulk</code></dt>
<dd>Retrieve records at once.</dd>
<dd>input: <code>DB</code>: (optional): the database identifier.</dd>
<dd>input: (optional): arbitrary keys which trail "_".</dd>
<dd>output: <code>num</code>: the number of retrieved reocrds.</dd>
<dd>output: (optional): arbitrary keys which trail the character "_".</dd>
<dd>status code: 200.</dd>
</dl>

<dl>
<dt><code>/rpc/vacuum</code></dt>
<dd>Scan the database and eliminate regions of expired records.</dd>
<dd>input: <code>DB</code>: (optional): the database identifier.</dd>
<dd>input: <code>step</code>: (optional): the number of steps.  If it is omitted or not more than 0, the whole region is scanned.</dd>
<dd>status code: 200.</dd>
</dl>

<dl>
<dt><code>/rpc/match_prefix</code></dt>
<dd>Get keys matching a prefix string.</dd>
<dd>input: <code>DB</code>: (optional): the database identifier.</dd>
<dd>input: <code>prefix</code>: the prefix string.</dd>
<dd>input: <code>max</code>: (optional): the maximum number to retrieve.  If it is omitted or negative, no limit is specified.</dd>
<dd>output: <code>num</code>: the number of retrieved keys.</dd>
<dd>output: (optional): arbitrary keys which trail the character "_".</dd>
<dd>status code: 200.</dd>
</dl>

<dl>
<dt><code>/rpc/match_regex</code></dt>
<dd>Get keys matching a ragular expression string.</dd>
<dd>input: <code>DB</code>: (optional): the database identifier.</dd>
<dd>input: <code>regex</code>: the regular expression string.</dd>
<dd>input: <code>max</code>: (optional): the maximum number to retrieve.  If it is omitted or negative, no limit is specified.</dd>
<dd>output: <code>num</code>: the number of retrieved keys.</dd>
<dd>output: (optional): arbitrary keys which trail the character "_".</dd>
<dd>status code: 200.</dd>
</dl>

<dl>
<dt><code>/rpc/cur_jump</code></dt>
<dd>Jump the cursor to the first record for forward scan.</dd>
<dd>input: <code>DB</code>: (optional): the database identifier.</dd>
<dd>input: <code>CUR</code>: the cursor identifier.</dd>
<dd>input: <code>key</code>: (optional): the key of the destination record.  If it is omitted, the first record is specified.</dd>
<dd>status code: 200, 450 (cursor is invalidated).</dd>
</dl>

<dl>
<dt><code>/rpc/cur_jump_back</code></dt>
<dd>Jump the cursor to a record for forward scan.</dd>
<dd>input: <code>DB</code>: (optional): the database identifier.</dd>
<dd>input: <code>CUR</code>: the cursor identifier.</dd>
<dd>input: <code>key</code>: (optional): the key of the destination record.  If it is omitted, the last record is specified.</dd>
<dd>status code: 200, 450 (cursor is invalidated), 501 (not implemented).</dd>
</dl>

<dl>
<dt><code>/rpc/cur_step</code></dt>
<dd>Step the cursor to the next record.</dd>
<dd>input: <code>CUR</code>: the cursor identifier.</dd>
<dd>status code: 200, 450 (cursor is invalidated).</dd>
</dl>

<dl>
<dt><code>/rpc/cur_step_back</code></dt>
<dd>Step the cursor to the previous record.</dd>
<dd>input: <code>CUR</code>: the cursor identifier.</dd>
<dd>status code: 200, 450 (cursor is invalidated), 501 (not implemented).</dd>
</dl>

<dl>
<dt><code>/rpc/cur_set_value</code></dt>
<dd>Set the value of the current record.</dd>
<dd>input: <code>CUR</code>: the cursor identifier.</dd>
<dd>input: <code>value</code>: the value of the record.</dd>
<dd>input: <code>step</code>: (optional): to move the cursor to the next record.  If it is omitted, the cursor stays at the current record.</dd>
<dd>input: <code>xt</code>: (optional): the expiration time from now in seconds.  If it is negative, the absolute value is treated as the epoch time.  If it is omitted, no expiration time is specified.</dd>
<dd>status code: 200, 450 (cursor is invalidated).</dd>
</dl>

<dl>
<dt><code>/rpc/cur_remove</code></dt>
<dd>Remove the current record.</dd>
<dd>input: <code>CUR</code>: the cursor identifier.</dd>
<dd>status code: 200, 450 (cursor is invalidated).</dd>
</dl>

<dl>
<dt><code>/rpc/cur_get_key</code></dt>
<dd>Get the key of the current record.</dd>
<dd>input: <code>CUR</code>: the cursor identifier.</dd>
<dd>input: <code>step</code>: (optional): to move the cursor to the next record.  If it is omitted, the cursor stays at the current record.</dd>
<dd>status code: 200, 450 (cursor is invalidated).</dd>
</dl>

<dl>
<dt><code>/rpc/cur_get_value</code></dt>
<dd>Get the value of the current record.</dd>
<dd>input: <code>CUR</code>: the cursor identifier.</dd>
<dd>input: <code>step</code>: (optional): to move the cursor to the next record.  If it is omitted, the cursor stays at the current record.</dd>
<dd>status code: 200, 450 (cursor is invalidated).</dd>
</dl>

<dl>
<dt><code>/rpc/cur_get</code></dt>
<dd>Get a pair of the key and the value of the current record.</dd>
<dd>input: <code>CUR</code>: the cursor identifier.</dd>
<dd>input: <code>step</code>: (optional): to move the cursor to the next record.  If it is omitted, the cursor stays at the current record.</dd>
<dd>output: <code>xt</code>: (optional): the absolute expiration time.  If it is omitted, there is no expiration time.</dd>
<dd>status code: 200, 450 (cursor is invalidated).</dd>
</dl>

<dl>
<dt><code>/rpc/cur_delete</code></dt>
<dd>Delete a cursor implicitly.</dd>
<dd>input: <code>CUR</code>: the cursor identifier.</dd>
<dd>status code: 200, 450 (cursor is invalidated).</dd>
</dl>

<h3 id="protocol_restful">RESTful interface</h3>

<p>While the procedure name is described in the URL in the above RPC-style interface, it is specified by the kind of method such as GET, HEAD, PUT, DELETE in the RESTful-style interface.  And, the objective record is described in the URL.  Because a lot of users prefers RESTful-style interface to RPC-style one, Kyoto Tycoon supports the both.  The following methods are used in the RESTful-style interface.</p>

<dl>
<dt><code>GET</code></dt>
<dd>Retrieve the value of a record.</dd>
<dd>request path: the key of the record.</dd>
<dd>response header: <code>Content-Length</code>: the size of the value.</dd>
<dd>response header: <code>X-Kt-Xt</code>: (optional): the absolute expiration time.  If it is omitted, there is no expiration time.</dd>
<dd>response entity body: the value of the record.</dd>
<dd>status code: 200, 404 (no record was found).</dd>
</dl>

<dl>
<dt><code>HEAD</code></dt>
<dd>Retrieve the value of a record.</dd>
<dd>request path: the key of the record.</dd>
<dd>response header: <code>Content-Length</code>: the size of the value.</dd>
<dd>response header: <code>X-Kt-Xt</code>: (optional): the absolute expiration time.  If it is omitted, there is no expiration time.</dd>
<dd>status code: 200, 404 (no record was found).</dd>
</dl>

<dl>
<dt><code>PUT</code></dt>
<dd>Set the value of a record.</dd>
<dd>request path: the key of the record.</dd>
<dd>request header: <code>Content-Length</code>: the size of the value.</dd>
<dd>request header: <code>X-Kt-Xt</code>: (optional): the absolute expiration time.  If it is omitted, no expiration time is specified.</dd>
<dd>request entity body: the value of the record.</dd>
<dd>status code: 201.</dd>
</dl>

<dl>
<dt><code>DELETE</code></dt>
<dd>Remove a record.</dd>
<dd>request path: the key of the record.</dd>
<dd>status code: 204, 404 (no record was found).</dd>
</dl>

<p>The space efficiency of RESTful-style interface is superior to the one of RPC-style interface because the entity body does not have any data structure and no encoding is needed.</p>

<p>The path of the URL in the request line must be encoded by URL encoding.  If the path begins with "/", the character is ignored and the trailing string is decoded.  Moreover, if the path includes "/" in the middle, the segment before the middle "/" is treated as the database identifier and the next segment is decoded as the key.  For example, the record whose key is "I love you" in the database "words.kch" is expressed "/words.kch/I%20love%20you" in the request line.</p>

<p>The format of date strings by the "X-Kt-Xt" header is the RFC 1123 date format of GMT.  The server understands the W3CDTF format, the RFC 822 (1123) format, and the decimal integer of seconds from the epoch.</p>

<hr />

<h2 id="license">License</h2>

<p>Kyoto Tycoon is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>

<p>Kyoto Tycoon is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p>

<p>You should have received a copy of the GNU General Public License along with this program.  If not, see `<code>http://www.gnu.org/licenses/</code>'.</p>

<p>Kyoto Tycoon was written and is maintained by FAL Labs.  You can contact the author by e-mail to `<code>info@fallabs.com</code>'.</p>

<hr />

</body>

</html>

<!-- END OF FILE -->
