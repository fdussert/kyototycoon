<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Language" content="en" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta name="author" content="FAL Labs" />
<meta name="keywords" content="Kyoto Tycoon, kyototycoon, database, DBM" />
<meta name="description" content="Specifications of Kyoto Tycoon" />
<link rel="contents" href="./" />
<link rel="stylesheet" href="common.css" />
<link rel="icon" href="icon16.png" />
<link rev="made" href="mailto:info@fallabs.com" />
<title>Fundamental Specifications of Kyoto Tycoon Version 1</title>
</head>

<body>

<h1 id="headline">Fundamental Specifications of Kyoto Tycoon Version 1</h1>

<div class="note">Copyright (C) 2009-2010 FAL Labs</div>
<div class="note">Last Update: Sun, 03 Oct 2010 21:36:09 +0900</div>

<hr />

<h2 id="contents">Table of Contents</h2>

<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#tutorial">Tutorial</a></li>
<li><a href="#tips">Tips and Hacks</a></li>
<li><a href="#license">License</a></li>
</ol>

<hr />

<h2 id="introduction">Introduction</h2>

<p>Kyoto Tycoon is a lightweight database server with auto expiration mechanism, which is useful to handle cache data of various applications.  Kyoto Tycoon is also a package of network interface to the DBM called Kyoto Cabinet.  Though the DBM has high performance and high concurrency, you might bother in case that multiple processes share the same database, or remote processes access the database.  Thus, Kyoto Tycoon is provided for concurrent and remote connections to Kyoto Cabinet.  Kyoto Tycoon is composed of the server process managing multiple databases and its access library for client applications.</p>

<p>The server features high concurrency due to thread-pool modeled implementation and the epoll/kqueue mechanism of the modern Linux/*BSD kernel.  It can handle more than 10 thousand connections at the same time.  Because such system-specific features as epoll/kqueue are encapsulated and abstracted as the same interface, Kyoto Tycoon has high portability and works almost all UNIX-like systems and Windows.</p>

<p>The server and its clients communicate with each other by HTTP.  So, you can write client applications and client libraries in almost all popular languages.  Both of RESTful-style interface by the GET, HEAD, PUT, DELETE methods and RPC-style inteface by the POST method are supported.  The RPC-style interface is based on the protocol called TSV-RPC.  The entity bodies of the request and the response are text data formatted as tab-separated-values so that parsing them is very easy.</p>

<p>The server program of Kyoto Tycoon is written in the C++ language.  It is available on platforms which have API conforming to C++03 with the TR1 library extensions.  Kyoto Tycoon is a free software licensed under the GNU General Public License.  You can write client applications which are not under control of our license, by making them just communicate with the server by HTTP without using the core library.</p>

<hr />

<h2 id="installation">Installation</h2>

<p>This section describes how to install Kyoto Tycoon with the source package.  As for a binary package, see its installation manual.</p>

<h3 id="installation_preparation">Preparation</h3>

<p>Kyoto Tycoon is available on UNIX-like systems.  At least, the following environments are supported.  Development for other platworms including Windows is now work-in-progress.</p>

<ul>
<li>Linux 2.6 and later (i386/x86-64/PowerPC/Alpha/SPARC)</li>
<li>Mac OS X 10.5 and later (x86-64)</li>
</ul>

<p><code>gcc</code> (GNU Compiler Collection) 4.2 or later and <code>make</code> (GNU Make) are required to install Kyoto Tycoon with the source package.  They are installed by default on Linux, FreeBSD and so on.</p>

<p>As Kyoto Tycoon depends on the following libraries, install them beforehand.</p>

<ul>
<li><a href="http://www.zlib.net/">ZLIB</a> : for loss-less data compression.  1.2.3 or later is required.</li>
<li><a href="http://fallabs.com/kyotocabinet/">Kyoto Cabinet</a> : lightweight embedded database library.  1.2.15 or later is required.</li>
</ul>

<h3 id="installation_installation">Installation</h3>

<p>When an archive file of Kyoto Tycoon is extracted, change the current working directory to the generated directory and perform installation.</p>

<p>Run the configuration script.</p>

<pre>$ ./configure
</pre>

<p>Build programs.</p>

<pre>$ make
</pre>

<p>Perform self-diagnostic test.  This takes a while.</p>

<pre>$ make check
</pre>

<p>Install programs.  This operation must be carried out by the <code>root</code> user.</p>

<pre># make install
</pre>

<h3 id="installation_result">Result</h3>

<p>When a series of work finishes, the following files will be installed.</p>

<pre>/usr/local/include/ktcommon.h
/usr/local/include/ktutil.h
/usr/local/include/ktsocket.h
/usr/local/include/ktthserv.h
/usr/local/include/kthttp.h
/usr/local/include/ktrpc.h
/usr/local/include/kttimeddb.h
/usr/local/include/ktremotedb.h
/usr/local/lib/libkyototycoon.a
/usr/local/lib/libkyototycoon.so.x.y.z
/usr/local/lib/libkyototycoon.so.x
/usr/local/lib/libkyototycoon.so
/usr/local/lib/pkgconfig/kyototycoon.pc
/usr/local/bin/ktutiltest
/usr/local/bin/ktutilmgr
/usr/local/bin/ktutilserv
/usr/local/bin/kttimedtest
/usr/local/bin/kttimedmgr
/usr/local/bin/ktserver
/usr/local/bin/ktremotetest
/usr/local/bin/ktremotemgr
/usr/local/share/kyototycoon/...
/usr/local/man/man1/...
</pre>

<h3 id="installation_option">Options of Configure</h3>

<p>The following options can be specified with `<code>./configure</code>'.</p>

<ul class="options">
<li><code>--enable-debug</code> : build for debugging.  Enable debugging symbols, do not perform optimization, and perform static linking.</li>
<li><code>--enable-devel</code> : build for development.  Enable debugging symbols, perform optimization, and perform dynamic linking.</li>
<li><code>--enable-profile</code> : build for profiling.  Enable profiling symbols, perform optimization, and perform dynamic linking.</li>
<li><code>--enable-static</code> : build by static linking.</li>
<li><code>--disable-shared</code> :  avoid to build shared libraries.</li>
</ul>

<p>`<code>--prefix</code>' and other options are also available as with usual UNIX software packages.  If you want to install Kyoto Tycoon under `<code>/usr</code>' not `<code>/usr/local</code>', specify `<code>--prefix=/usr</code>'.  As well, the library search path does not include `<code>/usr/local/lib</code>', it is necessary to set the environment variable `<code>LD_LIBRARY_PATH</code>' to include `<code>/usr/local/lib</code>' before running applications of Kyoto Tycoon.</p>

<h3 id="installation_library">How to Use the Library</h3>

<p>Kyoto Tycoon provides API of the C++ language and it is available by programs conforming to the C++03 standard.  As the header files of Kyoto Tycoon are provided as `<code>ktutil.h</code>', `<code>ktremotedb.h</code>', and so on, applications should include one or more of them accordingly to use the API.  As the library is provided as `<code>libkyototycoon.a</code>' and `<code>libkyototycoon.so</code>' and they depends on underlying system libraries, linker options corresponding to them are required by the build command.  The typical build command is the following.</p>

<pre>$ g++ -I/usr/local/include example.cc -o example \
  -L/usr/local/lib -lkyototycoon -lkyotocabinet -lz -lstdc++ \
  -lresolv -lnsl -ldl -lrt -lpthread -lm -lc
</pre>

<p>If you don't use the core library of C++ but an HTTP library in another language, you don't have to know the above messy rules.</p>

<hr />

<h2 id="tutorial">Tutorial</h2>

<p>This section describes how to use Kyoto Tycoon with the command line utilities and some sample application programs.</p>

<h3 id="tutorial_kickstart">Kick-start</h3>

<p>To begin with, let's run the database server program.  Simply execute the following commnad.  Some log messages are printed on the terminal.</p>

<pre>$ ktserver
2010-10-03T16:24:38.467252+09:00: [SYSTEM]: ================ [START]: pid=19069
2010-10-03T16:24:38.467473+09:00: [SYSTEM]: opening a database: path=*
2010-10-03T16:24:38.467645+09:00: [SYSTEM]: starting the server
2010-10-03T16:24:38.467751+09:00: [SYSTEM]: server socket opened: expr=:1978 timeout=30.0
2010-10-03T16:24:38.467775+09:00: [SYSTEM]: listening server socket started: fd=3
</pre>

<p>The command `<code>ktserver</code>' starts network service accepting commands from clients on local or remote machines.  By default, an unnamed on-memory database is opened and managed by the server through the port 1978.  To finish the server, input `<code>Ctrl-C</code>' on the terminal or send such termination signals as `<code>SIGINT</code>' or `<code>SIGTERM</code>' from another terminal.</p>

<p>Next, insert some records into the database.  Execute the follwoing command on another terminal.  Corresponding access logs will be printed on the server terminal.</p>

<pre>$ ktremotemgr set japan tokyo
$ ktremotemgr set korea seoul
$ ktremotemgr set china beijing
</pre>

<p>The command `<code>ktremotemgr</code>' is a tool kit to manage the database as a client.  The sub command "set" is to set a record.  The first argument next to the sub command name is the key of a record and the second argument is the value of the record.</p>

<p>Retrieve the records by the key of each record using the sub command "get".</p>

<pre>$ ktremotemgr get japan
tokyo
$ ktremotemgr get korea
seoul
$ ktremotemgr get china
beijing
</pre>

<p>Remove a record by the key using the sub command "remove".</p>

<pre>$ ktremotemgr remove japan
</pre>

<p>Print the keys of all records using the sub command "list".</p>

<pre>$ ktremotemgr list
korea
china
</pre>

<p>That's all for the fundamental operations.  The KVS family have been improving performance thanks to discarding the functionality.  See the specification of `<a href="command.html#ktserver">ktserver</a>' and `<a href="command.html#ktremotemgr">ktremotemgr</a>' for more detail.</p>

<h3 id="tutorial_httpcmd">Using HTTP Clients</h3>

<p>Because every operation of the database is called via HTTP, you can use any HTTP client utility such as `<code>curl</code>' to operate the database.</p>

<pre># setting records
$ curl "http://localhost:1978/rpc/set?key=japan&amp;value=tokyo"

# retrieving records
$ curl "http://localhost:1978/rpc/get?key=japan"
value   tokyo

# removing records
$ curl "http://localhost:1978/rpc/remove?key=japan"
</pre>

<p>RESTful-style interface is also supported in addition to the above RPC-style interface.</p>

<pre># setting records
$ echo -n tokyo | curl -X PUT -T - "http://localhost:1978/japan"

# retrieving records
$ curl "http://localhost:1978/japan"
tokyo

# removing records
$ curl -X DELETE "http://localhost:1978/japan"
</pre>

<p>Of cource, you can use your favorite scripting languages and libraries for more complex use cases.  Because Kyoto Tycoon supports keep-alive connection mechanism, using libraries which support keep-alive is strongly suggested for performance reason.</p>

<h3 id="tutorial_expiration">Expiration of Records</h3>

<p>One of the most important features of Kyoto Tycoon is expiration mechanism of records.  That is, you can specify the expiration time when inserting a record.  The record is automatically deleted after the current time exceeds the expiration time.</p>

<p>To insert a record which will be expired one minute after, execute the following command.</p>

<pre>$ ktremotemgr set -xt 60 japan tokyo
</pre>

<p>Check the record immediately before the expiration.  The "-pt" option shows the expiration time in seconds from the epoch.</p>

<pre>$ ktremotemgr get -pt japan
tokyo   1286108387
</pre>

<p>Wait for more than one minute, and then retrieve the record again.  It will be missing.</p>

<pre>$ ktremotemgr get -pt japan
ktremotemgr: DB::get failed: :1978: 2: logical inconsistency: DB: 7: no record: no record
</pre>

<p>You can do the same things with an arbitrary HTTP client by specifiying the "xt" parameter.</p>

<pre>$ curl "http://localhost:1978/rpc/set?key=japan&amp;value=tokyo&amp;xt=60"
$ curl "http://localhost:1978/rpc/get?key=japan"
value   tokyo
xt      1286109204
</pre>

<h3 id="tutorial_kctremoteex">Sample Application of the Remote Database</h3>

<p>Leaving command line interface, let's write a sample application program handling a remote database.  See the following source code.</p>

<pre>#include &lt;ktremotedb.h&gt;

using namespace std;
using namespace kyototycoon;

// main routine
int main(int argc, char** argv) {

  // create the database object
  RemoteDB db;

  // open the database
  if (!db.open()) {
    cerr &lt;&lt; "open error: " &lt;&lt; db.error().name() &lt;&lt; endl;
  }

  // store records
  if (!db.set("foo", "hop") ||
      !db.set("bar", "step") ||
      !db.set("baz", "jump")) {
    cerr &lt;&lt; "set error: " &lt;&lt; db.error().name() &lt;&lt; endl;
  }

  // retrieve a record
  string* value = db.get("foo");
  if (value) {
    cout &lt;&lt; *value &lt;&lt; endl;
    delete value;
  } else {
    cerr &lt;&lt; "get error: " &lt;&lt; db.error().name() &lt;&lt; endl;
  }

  // traverse records
  RemoteDB::Cursor* cur = db.cursor();
  cur-&gt;jump();
  pair&lt;string, string&gt;* rec;
  while ((rec = cur-&gt;get_pair(NULL, true)) != NULL) {
    cout &lt;&lt; rec-&gt;first &lt;&lt; ":" &lt;&lt; rec-&gt;second &lt;&lt; endl;
    delete rec;
  }
  delete cur;

  // close the database
  if (!db.close()) {
    cerr &lt;&lt; "close error: " &lt;&lt; db.error().name() &lt;&lt; endl;
  }

  return 0;
}
</pre>

<p>Save the above code as a file "example.cc".  Then, perform the following command line.  The command `<code>kcutilmgr conf</code>' prints the building configuration.</p>

<pre>$ g++ `ktutilmgr conf -i` -o example example.cc `ktutilmgr conf -l`
</pre>

<p>Execute the application program built by the above.  Of course, run the database server on another terminal beforehand.</p>

<pre>$ ./example
hop
foo:hop
bar:step
baz:jump
</pre>

<p>The API of the remote database is defined in the header `<code>ktremote.h</code>'.  So, include the header near the front of a source file.  All symbols of Kyoto Tycoon are packaged in the name space `<code>kyototycoon</code>'.  You can use them without any prefix by importing the name space.</p>

<pre>#include &lt;ktremotedb.h&gt;
using namespace kyototycoon;
</pre>

<p>The class `<code>RemoteDB</code>' contains all functionality of the remote database and each instance expresses a remote database file.</p>

<pre>RemoteDB db;
</pre>

<p>Each connection must be opened by the `<code>open</code>' method before any database operation.  Although it takes three parameters, all of them can be omitted.  The first parameter specifies the host name of the server and the default value is the name of the local host.  The second parameter specifies the port number and the default value is 1978 which is the same as the default port of the database server.  The third parameter specifies the timeout of network operation in seconds and the default value is no timeout.</p>

<pre>db.open();
</pre>

<p>Every opened connection should be closed by the `<code>close</code>' method when it is no longer in use.</p>

<pre>db.close();
</pre>

<p>To store a record, use the `<code>set</code>' method with the key and the value.</p>

<pre>db.put("foo", "hop");
</pre>

<p>To retrieve the value of a record, use the `<code>get</code>' method with the key.  The return value is NULL if no record corresponds to the key.  On success, the return value is the pointer to a dynamic object and it should be deleted explicitly after the use.</p>

<pre>string* value = db.get("foo", "hop");
if (value) {
  cout &lt;&lt; *value &lt;&lt; endl;
  delete value;
}
</pre>

<p>Except for `<code>set</code>' and `<code>get</code>', there are other methods; `<code>add</code>', `<code>replace</code>', `<code>append</code>', `<code>remove</code>', `<code>increment</code>', and `<code>cas</code>'.  Each method has two versions; for `<code>std::string</code>' parameters and for `<code>char*</code>' and `<code>size_t</code>' parameters.</p>

<p>Traversing records is a bit complicated task.  It needs a cursor object, which expresses the current position in the sequence of all records in the database.  Each cursor is created by the `<code>cursor</code>' method of the database object.  Each cursor should be initialized by `<code>jump</code>' method before actual record operations.</p>

<pre>RemoteDB::Cursor* cur = db.cursor();
cur-&gt;jump();
</pre>

<p>The cursor class has such methods against the record at the current position as `<code>set_value</code>', `<code>remove</code>', `<code>get_key</code>', `<code>get_value</code>', and `<code>get_pair</code>'.  Most methods have an optional stepping parameter to shift the current position to the next record atomically.  Therefore, iterating such methods with the stepping parameter results in that all records are visited.</p>

<pre>pair&lt;string, string&gt;* rec;
while ((rec = cur.get_pair(true)) != NULL) {
  cout &lt;&lt; rec-&gt;first &lt;&lt; ":" &lt;&lt; rec-&gt;second &lt;&lt; endl;
  delete rec;
}
</pre>

<p>Please see the <a href="api/">the API documents</a> for detail.  Writing your own sample application is the best way to learn this library.  <a href="command.html">The specifications of command line utilities</a> is also useful.</p>

<hr />

<h2 id="tips">Tips and Hacks</h2>

<p>This section describes tips and hacks to use Kyoto Tycoon.</p>

<h3 id="tips_typicalserver">Typical Server Setting</h3>

<p>On the assumption that you runs the server of Kyoto Tycoon on an machine with 16GB main memory and stores 10 million records into a file hash database, the following setting is suggested.</p>

<pre>$ ktserver -port 1978 -tout 10 \
  -log /var/data/ktserver.log -ls \
  -dmn -pid /var/data/ktserver.pid \
  '/var/data/casket.kch#bnum=20000000#msiz=12g#dfunit=8'
</pre>

<p>To improve performance, the bucket number of the hash table by the "bnum" parameter should be two times or more of the number of records.  The size of mapped memory by the "msiz" parameter should be largest as far as the main memory is available.  The unit number of auto defragmentation by the "dfunit" parameter should be about 8 which means every eight detected fragmentations causes a series of auto defragmentation steps.  If you want more high availability at the cost of performance, using auto transaction by the "-oat" option is a good idea.  For detail about database tuning, see <a href="http://fallabs.com/kyotocabinet/spex.html#tips">the tips of Kyoto Cabinet</a>.</p>

<p>The option "-dmn" switches the process into the background, which is called daemon.  To stop or restart a daemon process, the PID files should be specified by the "-pid" parameter.  The PID file contains the process ID by which you can send signals.</p>

<p>By default, verbose log messages are output and printed into the standard output.  For usual use case, the "-ls" option which filters them is suggested.  The "-log" option specifies the file to store log messages.</p>

<p>To stop the above daemon process, execute the following command.</p>

<pre>$ kill -TERM `cat /var/data/ktserver.pid`
</pre>

<p>To rotate the log file of the above daemon process, execute the following command.</p>

<pre>$ mv -f /var/data/ktserver.log /var/data/ktserver.log.`date '+%Y%M%d%H%M%S'`
$ kill -HUP `cat /var/data/ktserver.pid`
</pre>

<h3 id="tips_hotbackup">Hot Backup</h3>

<p>You can make backup files while the server is running, which is called "hot backup".  To do it, prepare the following shell script beforehand and save it as "/ktbin/dbbackup".  It must have exetutable permissions.</p>

<pre>#! /bin/sh
srcfile="$1"
destfile="$1.`date '+%Y%M%d%H%M%S'`"
cp -f "$srcfile" "$destfile"
</pre>

<p>Run the server specifiying the command search path "/ktbin".</p>

<pre>$ ktserver -cmd /ktbin casket.kch
</pre>

<p>When you want to make a backup file, execute the following command to call the backup script.</p>

<pre>$ ktremotemgr sync -cmd dbbackup
</pre>

<p>The "sync" sub command of the client utility makes the database synchronize, which means dirty buffers on memory are written into the database file.  If the "-cmd" option is specified, an outer command is executed with one argument which is the path of the database file.  You can call arbitrary scripts other than the above sample.  Using "snapshot" mechanism of the underlying operating system is a good idea to shorten the time to make a backup file.</p>

<hr />

<h2 id="license">License</h2>

<p>Kyoto Tycoon is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>

<p>Kyoto Tycoon is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p>

<p>You should have received a copy of the GNU General Public License along with this program.  If not, see `<code>http://www.gnu.org/licenses/</code>'.</p>

<p>Kyoto Tycoon was written and is maintained by FAL Labs.  You can contact the author by e-mail to `<code>info@fallabs.com</code>'.</p>

<hr />

</body>

</html>

<!-- END OF FILE -->
